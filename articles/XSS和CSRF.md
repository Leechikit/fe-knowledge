# XSS 和 CSRF

## XSS攻击(cross-site script)

通过html标签注入，篡改网页，插入恶意的脚本，前端可能没有经过严格的校验直接就进到数据库，数据库又通过前端程序又回显到浏览器

### 防御

前端要对用户输入的信息进行过滤，可以用正则，通过替换标签的方式进行转码或解码。
例如<> 空格 & '' ""等替换成html编码。

<details>
<summary>CODE</summary>

```
function htmlEncode(val) {
    return val.replace(/[&<> "']/g, function (c) {
        return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            ' ': '&nbsp;',
            '"': '&quot;',
            "'": '&#39;'
        }[c];
    });
}
```

</details>

## CSRF攻击(cross site request forgery,跨站请求伪造)

xss是站点用户进行攻击，而csrf是通过伪装成站点用户进行攻击。

攻击者盗用用户的身份信息，并以用户的名义进行发送恶意的请求等，例如发邮件，盗取账号等非法手段。

栗子：
> 你登录网站，并在本地种下了cookie。
> 
> 如果在没退出该网站的时候 不小心访问了恶意网站，而且这个网站需要你发一些请求等。
> 
> 此时，你是携带cookie进行访问的，那么你的重在cookie里的信息就会被恶意网站捕捉到，那么你的信息就被盗用，导致一些不法分子做一些事情。

### 防御

* 验证HTTP Referer字段
> 在HTTP头中有Referer字段，他记录该HTTP请求的来源地址，如果跳转的网站与来源地址相符，那就是合法的，如果不符则可能是csrf攻击，拒绝该请求

* 在请求地址中添加token并验证
> 在请求的时候加一个token，值可以是随机产生的一段数字，token是存入数据库之后，后台返给客户端的，如果客户端再次登录的时候，后台发现token没有，或者通过查询数据库不正确，那么就拒绝该请求。
>
> 如果想防止一个账号避免在不同的机器上登录，那么我们就可以通过token来判断，如果a机器登录后，我们就将用户的token从数据库清除，从新生成，那么另外一台b机器在执行操作的时候，token就失效了，只能重新登录，这样就可以防止两台机器登同一账号。

* 输入验证码
> 每个请求使用验证码，这个方案是完美的，因为要多次输入验证码，所以用户友好性很差，所以不适合实际运用。

* 在HTTP头中自定义属性并验证